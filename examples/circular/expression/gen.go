// Code generated by oapi-codegen. DO NOT EDIT.

package expression

import (
	"fmt"

	"github.com/doordash/oapi-codegen-dd/v3/pkg/runtime"
	"github.com/go-playground/validator/v10"
)

var bodyTypesValidate *validator.Validate

func init() {
	bodyTypesValidate = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(bodyTypesValidate)
}

type ApplyFilterBody = FilterRequest

type ApplyFilterResponse struct {
	Result *string `json:"result,omitempty"`
}

var schemaTypesValidate *validator.Validate

func init() {
	schemaTypesValidate = validator.New(validator.WithRequiredStructEnabled())
	runtime.RegisterCustomTypeFunc(schemaTypesValidate)
}

type FilterRequest struct {
	Filter *Expression `json:"filter,omitempty"`
}

func (f FilterRequest) Validate() error {
	if f.Filter != nil {
		if v, ok := any(f.Filter).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				return runtime.NewValidationErrorFromError("Filter", err)
			}
		}
	}
	return nil
}

type Expression struct {
	Or         Expressions      `json:"Or,omitempty"`
	And        Expressions      `json:"And,omitempty"`
	Not        *Expression      `json:"Not,omitempty"`
	Dimensions *DimensionValues `json:"Dimensions,omitempty"`
}

func (e Expression) Validate() error {
	if v, ok := any(e.Or).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			return runtime.NewValidationErrorFromError("Or", err)
		}
	}
	if v, ok := any(e.And).(runtime.Validator); ok {
		if err := v.Validate(); err != nil {
			return runtime.NewValidationErrorFromError("And", err)
		}
	}
	if e.Not != nil {
		if v, ok := any(e.Not).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				return runtime.NewValidationErrorFromError("Not", err)
			}
		}
	}
	if e.Dimensions != nil {
		if v, ok := any(e.Dimensions).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				return runtime.NewValidationErrorFromError("Dimensions", err)
			}
		}
	}
	return nil
}

type Expressions []Expression

func (e Expressions) Validate() error {
	if e == nil {
		return nil
	}
	if len(e) < 1 {
		return runtime.NewValidationError("", fmt.Sprintf("must have at least 1 items, got %d", len(e)))
	}
	for i, item := range e {
		if v, ok := any(item).(runtime.Validator); ok {
			if err := v.Validate(); err != nil {
				return runtime.NewValidationErrorFromError(fmt.Sprintf("[%d]", i), err)
			}
		}
	}
	return nil
}

type DimensionValues struct {
	Key    *string  `json:"Key,omitempty"`
	Values []string `json:"Values,omitempty"`
}

func (d DimensionValues) Validate() error {
	return schemaTypesValidate.Struct(d)
}
